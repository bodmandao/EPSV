{
  "language": "Solidity",
  "sources": {
    "contracts/OGVaultPay.sol": {
      "content": "pragma solidity ^0.8.19;\n\n/// @title OGVaultPay - simple deposit/withdraw hub for native & ERC20 payments\n/// @notice Accepts native or ERC20 deposits on behalf of recipients, tracks balances, emits events.\n/// @dev Uses OpenZeppelin patterns (SafeERC20 semantics implemented inline to avoid imports requirement).\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\nabstract contract ReentrancyGuard {\n    uint256 private _status;\n    constructor() { _status = 1; }\n    modifier nonReentrant() {\n        require(_status == 1, \"Reentrant\");\n        _status = 2;\n        _;\n        _status = 1;\n    }\n}\n\ncontract OGVaultPay is ReentrancyGuard {\n    address public owner;\n\n    // token == address(0) denotes native token (OG)\n    // balances[token][recipient] => amount\n    mapping(address => mapping(address => uint256)) public balances;\n\n    event Deposit(address indexed token, address indexed from, address indexed recipient, uint256 amount);\n    event Withdraw(address indexed token, address indexed recipient, address indexed to, uint256 amount);\n    event Rescue(address indexed token, address indexed to, uint256 amount);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"OGVaultPay: caller is not owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    /// @notice Deposit funds for a recipient. If token == address(0) send native with msg.value.\n    /// @param token address(0) for native, otherwise ERC20 token address\n    /// @param recipient the address credited in internal ledger\n    /// @param amount amount to deposit (in wei or token decimals)\n    function deposit(address token, address recipient, uint256 amount) external payable nonReentrant {\n        require(recipient != address(0), \"OGVaultPay: recipient zero\");\n        if (token == address(0)) {\n            // native deposit\n            require(msg.value == amount, \"OGVaultPay: msg.value mismatch\");\n            balances[address(0)][recipient] += amount;\n        } else {\n            // ERC20 deposit - caller must have approved contract\n            require(msg.value == 0, \"OGVaultPay: do not send native when depositing ERC20\");\n            // transferFrom sender -> this\n            bool ok = IERC20(token).transferFrom(msg.sender, address(this), amount);\n            require(ok, \"OGVaultPay: ERC20 transferFrom failed\");\n            balances[token][recipient] += amount;\n        }\n\n        emit Deposit(token, msg.sender, recipient, amount);\n    }\n\n    /// @notice Withdraw balance for msg.sender (recipient). Withdraws native or ERC20 to `to`.\n    /// @param token address(0) for native, otherwise ERC20 token address\n    /// @param to recipient external address where funds will be sent\n    /// @param amount amount to withdraw\n    function withdraw(address token, address to, uint256 amount) external nonReentrant {\n        require(to != address(0), \"OGVaultPay: to zero\");\n        uint256 bal = balances[token][msg.sender];\n        require(bal >= amount, \"OGVaultPay: insufficient balance\");\n        balances[token][msg.sender] = bal - amount;\n\n        if (token == address(0)) {\n            // native transfer\n            (bool sent, ) = to.call{value: amount}(\"\");\n            require(sent, \"OGVaultPay: native send failed\");\n        } else {\n            bool ok = IERC20(token).transfer(to, amount);\n            require(ok, \"OGVaultPay: ERC20 transfer failed\");\n        }\n\n        emit Withdraw(token, msg.sender, to, amount);\n    }\n\n    /// @notice Owner rescue function - withdraw accidental tokens/native to `to`.\n    /// @param token token address to rescue (address(0) for native)\n    /// @param to destination\n    /// @param amount amount to rescue\n    function rescue(address token, address to, uint256 amount) external onlyOwner nonReentrant {\n        require(to != address(0), \"OGVaultPay: to zero\");\n\n        if (token == address(0)) {\n            uint256 nativeBal = address(this).balance;\n            require(nativeBal >= amount, \"OGVaultPay: insufficient native\");\n            (bool sent, ) = to.call{value: amount}(\"\");\n            require(sent, \"OGVaultPay: native rescue failed\");\n        } else {\n            uint256 tokenBal = IERC20(token).balanceOf(address(this));\n            require(tokenBal >= amount, \"OGVaultPay: insufficient token\");\n            bool ok = IERC20(token).transfer(to, amount);\n            require(ok, \"OGVaultPay: token rescue failed\");\n        }\n\n        emit Rescue(token, to, amount);\n    }\n\n    /// @notice Update owner\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"OGVaultPay: newOwner zero\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    // Allow the contract to receive native\n    receive() external payable {\n        // If someone sends native without calling deposit, credit their own ledger\n        balances[address(0)][msg.sender] += msg.value;\n        emit Deposit(address(0), msg.sender, msg.sender, msg.value);\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}